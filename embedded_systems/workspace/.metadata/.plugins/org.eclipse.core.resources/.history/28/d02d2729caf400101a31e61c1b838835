/* NAME: 		 SOLEIL DEMICK
 * COURSE: 		 ENGS 28 261 LAB 2
 * PROGRAM NAME: blinkyCNT_BTN.c
 * DESCRIPTION:  Toggle the functionality of blinkyCNT.c from an external button.
 * DEPENDENCIES: N/A
 * I/O PINS:
 * 		PA 5, 6, 7 : OUTPUT, EXTERNAL LEDS
 * 		PB 4 : INPUT, BUTTON
 * REVISIONS:
 * 		BASED ON blinkyCNT.c
 */


// INCLUDE FILES
#include "ES28.h"

// CONSTANTS
// Clock access for ports A and B
#define GPIOAEN	(1U<<0)
#define GPIOBEN (1U<<1)

// Port A pins 5, 6 7
#define LED_PIN1 (1U<<5)
#define LED_PIN2 (1U<<6)
#define LED_PIN3 (1U<<7)

// Port B pin 4
#define BUTTON_PIN (1U<<4)

// easy reference for setting/clearing all LED pins at once
#define LED_ALL (LED_PIN1 | LED_PIN2 | LED_PIN3)
// counter to track which pins are high
uint32_t count = 0;

int main(void) {
	RCC->IOPENR |= (GPIOAEN | GPIOBEN);		// Enable clock access to GPIOA

	// Configure LED pins as outputs
	GPIOA->MODER |=  (1U<<10); // PA5
	GPIOA->MODER &= ~(1U<<11);
	GPIOA->MODER |=  (1U<<12); // PA6
	GPIOA->MODER &= ~(1U<<13);
	GPIOA->MODER |=  (1U<<14); // PA7
	GPIOA->MODER &= ~(1U<<15);

	// Configure button pin as input
	GPIOB->MODER &= ~(1U<<8);
	GPIOB->MODER &= ~(1U<<9);

	// Enable pull-up resistor on button pin
	GPIOB->PUPDR |=  (1U<<8);
	GPIOB->PUPDR &= ~(1U<<9);

	// variables for button state
	unsigned countDisabled = 0;
	unsigned buttonPressed = 0;

	while(1) {
		buttonPressed = ((GPIOB->IDR & BUTTON_PIN) == 0); // poll the button

		GPIOA->ODR &= ~LED_ALL; // clear LED pins
		GPIOA->ODR |= count<<5; // shift counter to correct position and set bits 5-7
		if (countDisabled) {
			if (buttonPressed) {
				countDisabled = 0;
			}
			count++;
			count %= 8;
			delay_ms(500);
		} else {
			if (buttonPressed) {
				countdisabled = 1;
			}
		}
	}
	return 0;
}
